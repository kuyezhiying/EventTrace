${
    // Enable extension methods by adding using Typewriter.Extensions.
    using Typewriter.Extensions.Types;

    // Uncomment the constructor to change template settings.
    Template(Settings settings)
    {
        settings.IncludeProject("Models");

        settings.OutputFilenameFactory = file =>
        {
            return $"{file.Name.Replace(".cs", ".d.ts")}";
        };
    }

    string GetPropertyName(Property property)
    {
        var attribs = property.Attributes;
        if (attribs.Any(x => x.Name == "Required"))
        {
            return property.Name;
        }
        else
        {
            return property.Name + "?";
        }
    }

    string GetCamelCasePropertyname(Property property)
    {
        // By using the lower case property.name the property name will be printed in camel case
        var attribs = property.Attributes;
        if (attribs.Any(x => x.Name == "Required"))
        {
            return property.name;
        }
        else
        {
            return property.name + "?";
        }
    }

    string GetTypeName(Property property)
    {
        if (property.Type == "Date")
        {
            return "string";
        }

        return property.Type;
    }

    string GetBaseClass(Class c) {
        if (c.BaseClass != null) {
            return " extends " + c.BaseClass;
        }

        return "";
    }

    // $Classes/Enums/Interfaces(filter)[template][separator]
    // filter (optional): Matches the name or full name of the current item. * = match any, wrap in [] to match attributes or prefix with : to match interfaces or base classes.
    // template: The template to repeat for each matched item
    // separator (optional): A separator template that is placed between all templates e.g. $Properties[public $name: $Type][, ]

    // More info: http://frhagn.github.io/Typewriter/

    // 2. change the following to your entity name

    // DONT FORMAT CODE. OTHERWISE IT INSERTS UNWANTED WHITESPACES WHICH BREAKS THE LINTER.
}// Auto-generated by typewriter from C# model
$Classes(c => c is Class && c.Attributes.All(a => (a.Name != "IgnoreFromModelGenerator" && (a.Name != "JsonObject" || !a.Value.Contains("CamelCaseNamingStrategy")))))[interface $Name$GetBaseClass {$Properties[
    $GetPropertyName: $GetTypeName;]
}]$Classes(c => c is Class && c.Attributes.All(a => a.Name != "IgnoreFromModelGenerator") && c.Attributes.Any(a => a.Name == "JsonObject" && a.Value.Contains("CamelCaseNamingStrategy")))[interface $Name$GetBaseClass {$Properties[
    $GetCamelCasePropertyname: $GetTypeName;]
}]